<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xiong Hai Zi]]></title>
  <subtitle><![CDATA[熊孩子的学习]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://biancheng.me/"/>
  <updated>2015-11-30T06:10:05.261Z</updated>
  <id>http://biancheng.me/</id>
  
  <author>
    <name><![CDATA[熊孩子]]></name>
    <email><![CDATA[jmme@foxmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Core Data基本介绍]]></title>
    <link href="http://biancheng.me/2015/11/30/core-data%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://biancheng.me/2015/11/30/core-data基本介绍/</id>
    <published>2015-11-30T06:08:25.000Z</published>
    <updated>2015-11-30T06:09:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>大概10年前，在2005年4月，Apple发布了OS X 10.4版本，第一次引入了Core Data框架。那时YouTube也刚发布。</p>
<p>Core Data提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象。简单地用下图描述下它的作用：<br>  <img src="img/1359705997_4313.png" alt="core data"></p>
<p>  左边是关系模型，即数据库，数据库里面有张person表，person表里面有id、name、age三个字段，而且有2条记录；<br>右边是对象模型，可以看到，有2个OC对象；<br>利用Core Data框架，我们就可以轻松地将数据库里面的2条记录转换成2个OC对象，也可以轻松地将2个OC对象保存到数据库中，变成2条表记录，而且不用写一条SQL语句。</p>
<p>Core Data是模型层的技术。Core Data帮助你构建代表程序状态的模型层。Core Data也是一种持久化技术，它可以将模型的状态持久化到磁盘。但它更重要的特点是：Core Data不只是一个加载和保存数据的框架，它也能处理内存中的数据。</p>
<p>如果你曾接触过Object-relational mapping(O/RM)，Core Data不仅是一种O/RM。如果你曾接触过SQL wrappers, Core Data也不是一种SQL wrapper。它确实默认使用SQL，但是，它是一种更高层次的抽象概念。如果你需要一个O/RM或者SQL wrapper，那么Core Data并不适合你。</p>
<blockquote>
<p>Core Data提供的最强大的功能之一是它的对象图形管理。为了更有效的使用Core Data, 你需要理解这一部分内容。</p>
</blockquote>
<p>还有一点需要注意：Core Data完全独立于任何UI层的框架。从设计的角度来说，它是完全的模型层的框架。</p>
<h3 id="堆栈The_Stack">堆栈The Stack</h3>
<p>Core Data中有不少组件，它是一种非常灵活的技术。在大多数使用情况里，设置相对来说比较简单。</p>
<p>当所有组件绑定在一起，我们把它们称为Core Data Stack. 这种堆栈有两个主要部分。一部分是关于对象图管理，这是你需要掌握好的部分，也应该知道怎么使用。第二部分是关于持久化的，比如保存模型对象的状态和再次恢复对象的状态。</p>
<p>在这两部分的中间，即堆栈中间，是持久化存储协调器(Persistent Store Coordinator, PSC)，也被朋友们戏称做中心监视局。通过它将对象图管理部分和持久化部分绑在一起。当这两部分中的一部分需要和另一部分交互，将通过PSC来调节。</p>
<p><img src="img/7cc829d3gw1eap6hhq1gkj20yo108wi0.jpg" alt="core data"></p>
<p>对象图管理是你的应用中模型层逻辑存在的地方。模型层对象存在于一个context里。在大多数设置中，只有一个context，所有的对象都放在这个context中。Core Data支持多个context，但是是针对更高级的使用情况。需要注意的是，每个context和其他context区分都很清楚。有个重要的事需要记住，对象和他们的context绑定在一起。每一个被管理的对象都知道它属于哪个context，每一个context也知道它管理着哪些对象。</p>
<p>堆栈的另一部分是持久化发生的地方，比如Core Data从文件系统读或写。在所有情况下，持久化存储协调器(PSC)有一个属于自己的的持久化存储器(persistent store)，这个store在文件系统和SQLite数据库交互。为了支持更高级的设置，Core Data支持使用多个存储器附属于同一个持久化存储协调器，并且除了SQL，还有一些别的存储类型可以选择。</p>
<p>一个常见的解决方案，看起来是这个样子的：</p>
<p><img src="img/7cc829d3gw1eap6hgqs2xj20uk0gaq41.jpg" alt="core data"></p>
<h2 id="模型文件">模型文件</h2>
<p>在Core Data，需要进行映射的对象称为实体(entity)，而且需要使用Core Data的模型文件来描述app中的所有实体和实体属性。这里以Person(人)和Card(身份证)2个实体为例子，先看看实体属性和实体之间的关联关系：<br><img src="img/1359707024_5895.png" alt="core data"><br>Person实体中有：name（姓名）、age（年龄）、card（身份证）三个属性<br>Card实体中有：no（号码）、person（人）两个属性</p>
<p>接下来看看创建模型文件的过程：</p>
<p>1.选择模板</p>
<p><img src="img/1359707426_5763.png" alt="core data"></p>
<p>2.添加实体</p>
<p><img src="img/1359707563_9302.png" alt="core data"></p>
<p>3.添加Person的2个基本属性</p>
<p><img src="img/1359707773_7614.png" alt="core data"></p>
<p>4.添加Card的1个基本属性</p>
<p><img src="img/1359707796_4561.png" alt="core data"></p>
<p>5.建立Card和Person的关联关系</p>
<p><img src="img/1359708105_6064.png" alt="core data"></p>
<p>上图中的<img src="img/1359708186_1349.png" alt="core data">表示Card中有个Person类型的person属性，目的就是建立Card跟Person之间的一对一关联关系(建议补上这一项)，在Person中加上Inverse属性后，你会发现Card中Inverse属性也自动补上了</p>
<p><img src="img/1359708436_2378.png" alt="core data"></p>
<h2 id="了解NSManagedObject">了解NSManagedObject</h2>
<p>1.上面创建的模型，默认情况下都是NSManagedObject类型，对应的Core Data中的模型对象都是NSManagedObject类的对象</p>
<p><img src="img/1359708744_9527.png" alt="core data"></p>
<p>2.NSManagedObject的工作模式有点类似于NSDictionary对象，通过键-值对来存取所有的实体属性<br>1&gt; setValue:forKey:存储属性值(属性名为key)<br>2&gt; valueForKey:获取属性值(属性名为key)</p>
<h2 id="代码实现">代码实现</h2>
<p>先添加CoreData.framework和导入主头文件<CoreData/CoreData.h></p>
<p><img src="img/1359710937_3208.png" alt="core data"></p>
<p>1.搭建上下文环境</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>// 从应用程序包中加载模型文件  
NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:<span class="keyword">nil</span>];  
// 传入模型对象，初始化NSPersistentStoreCoordinator  
NSPersistentStoreCoordinator *psc = <span class="string">[[[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model] autorelease];  
// 构建SQLite数据库文件的路径  
NSString *docs = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];  
NSURL *url = [NSURL fileURLWithPath:[docs stringByAppendingPathComponent:@"person.data"]]</span>;  
// 添加持久化存储库，这里使用SQLite作为存储库  
NSError *<span class="built_in">error</span> = <span class="keyword">nil</span>;  
NSPersistentStore *store = [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:<span class="keyword">nil</span> URL:url options:<span class="keyword">nil</span> <span class="built_in">error</span>:&<span class="built_in">error</span>];  
<span class="keyword">if</span> (store == <span class="keyword">nil</span>) { // 直接抛异常  
    [NSException raise:@<span class="string">"添加数据库错误"</span> format:@<span class="string">"%@"</span>, [<span class="built_in">error</span> localizedDescription]];  
}  
// 初始化上下文，设置persistentStoreCoordinator属性  
NSManagedObjectContext *context = <span class="string">[[NSManagedObjectContext alloc] init];  
context.persistentStoreCoordinator = psc;</span>
</pre></td></tr></table></figure>


<p>2.添加数据到数据库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 传入上下文，创建一个Person实体对象  </span>
NSManagedObject *person = [NSEntityDescription insertNewObjectForEntityForName:@<span class="string">"Person"</span> inManagedObjectContext:context];  
<span class="comment">// 设置Person的简单属性  </span>
[person setValue:@<span class="string">"MJ"</span> forKey:@<span class="string">"name"</span>];  
[person setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">27</span>] forKey:@<span class="string">"age"</span>];  
<span class="comment">// 传入上下文，创建一个Card实体对象  </span>
NSManagedObject *card = [NSEntityDescription insertNewObjectForEntityForName:@<span class="string">"Card"</span> inManagedObjectContext:context];  
[card setValue:@<span class="string">"4414241933432"</span> forKey:@<span class="string">"no"</span>];  
<span class="comment">// 设置Person和Card之间的关联关系  </span>
[person setValue:card forKey:@<span class="string">"card"</span>];  
<span class="comment">// 利用上下文对象，将数据同步到持久化存储库  </span>
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;  
<span class="built_in">BOOL</span> success = [context save:&error];  
<span class="keyword">if</span> (!success) {  
    [<span class="built_in">NSException</span> raise:@<span class="string">"访问数据库错误"</span> format:@<span class="string">"%@"</span>, [error localizedDescription]];  
}  
<span class="comment">// 如果是想做更新操作：只要在更改了实体对象的属性后调用[context save:&error]，就能将更改的数据同步到数据库</span>
</pre></td></tr></table></figure>


<p>3.从数据库中查询数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">// 初始化一个查询请求  </span>
NSFetchRequest *request = [[[NSFetchRequest alloc] init] autorelease];  
<span class="comment">// 设置要查询的实体  </span>
request<span class="variable">.entity</span> = [NSEntityDescription entityForName:@<span class="string">"Person"</span> inManagedObjectContext:context];  
<span class="comment">// 设置排序（按照age降序）  </span>
NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@<span class="string">"age"</span> ascending:<span class="literal">NO</span>];  
request<span class="variable">.sortDescriptors</span> = [<span class="built_in">NSArray</span> arrayWithObject:sort];  
<span class="comment">// 设置条件过滤(搜索name中包含字符串"Itcast-1"的记录，注意：设置条件过滤时，数据库SQL语句中的%要用*来代替，所以%Itcast-1%应该写成*Itcast-1*)  </span>
NSPredicate *predicate = [NSPredicate predicateWithFormat:@<span class="string">"name like %@"</span>, @<span class="string">"*Itcast-1*"</span>];  
request<span class="variable">.predicate</span> = predicate;  
<span class="comment">// 执行请求  </span>
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;  
<span class="built_in">NSArray</span> *objs = [context executeFetchRequest:request error:&error];  
<span class="keyword">if</span> (error) {  
    [<span class="built_in">NSException</span> raise:@<span class="string">"查询错误"</span> format:@<span class="string">"%@"</span>, [error localizedDescription]];  
}  
<span class="comment">// 遍历数据  </span>
<span class="keyword">for</span> (NSManagedObject *obj in objs) {  
    <span class="built_in">NSLog</span>(@<span class="string">"name=%@"</span>, [obj valueForKey:@<span class="string">"name"</span>]  
}
</pre></td></tr></table></figure>


<p>注：Core Data不会根据实体中的关联关系立即获取相应的关联对象，比如通过Core Data取出Person实体时，并不会立即查询相关联的Card实体；当应用真的需要使用Card时，才会再次查询数据库，加载Card实体的信息。这个就是Core Data的延迟加载机制</p>
<p>4.删除数据库中的数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>// 传入需要删除的实体对象  
[context deleteObject:managedObject];  
// 将结果同步到数据库  
NSError *<span class="built_in">error</span> = <span class="keyword">nil</span>;  
[context save:&<span class="built_in">error</span>];  
<span class="keyword">if</span> (<span class="built_in">error</span>) {  
    [NSException raise:@<span class="string">"删除错误"</span> format:@<span class="string">"%@"</span>, [<span class="built_in">error</span> localizedDescription]];  
}
</pre></td></tr></table></figure>


<h2 id="打开CoreData的SQL语句输出开关">打开CoreData的SQL语句输出开关</h2>
<p>1.打开Product，点击EditScheme…<br>2.点击Arguments，在ArgumentsPassed On Launch中添加2项<br>1&gt; -com.apple.CoreData.SQLDebug<br>2&gt; 1<img src="img/1359711942_1857.png" alt="core data"><img src="img/1359711964_1550.png" alt="core data"></p>
<h2 id="创建NSManagedObject的子类">创建NSManagedObject的子类</h2>
<p>默认情况下，利用Core Data取出的实体都是NSManagedObject类型的，能够利用键-值对来存取数据。但是一般情况下，实体在存取数据的基础上，有时还需要添加一些业务方法来完成一些其他任务，那么就必须创建NSManagedObject的子类</p>
<p><img src="img/1359712054_3978.png" alt="core data"></p>
<p>选择模型文件</p>
<p><img src="img/1359712079_5045.png" alt="core data"></p>
<p>选择需要创建子类的实体 </p>
<p><img src="img/1359712094_5888.png" alt="core data"></p>
<p>创建完毕后，多了2个子类</p>
<p><img src="img/1359712116_3772.png" alt="core data"></p>
<p>文件内容展示：</p>
<p>Person.h</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span>  </span>
<span class="preprocessor">#import <span class="title">&lt;CoreData/CoreData.h&gt;</span>  </span>
  
<span class="class"><span class="keyword">@class</span> <span class="title">Card</span>;  </span>
  
<span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSManagedObject</span>  </span>
  
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSString</span> * name;  
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSNumber</span> * age;  
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) Card *card;  
  
<span class="keyword">@end</span>
</pre></td></tr></table></figure>


<p>Person.m</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="id">#import</span> "<span class="tag">Person</span><span class="class">.h</span>"  
  
<span class="at_rule">@<span class="keyword">implementation</span> Person  
  
@dynamic name</span>;  
<span class="at_rule">@<span class="keyword">dynamic</span> age</span>;  
<span class="at_rule">@<span class="keyword">dynamic</span> card</span>;  
  
<span class="at_rule">@<span class="keyword">end</span></span>
</pre></td></tr></table></figure>


<p>Card.h</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span>  </span>
<span class="preprocessor">#import <span class="title">&lt;CoreData/CoreData.h&gt;</span>  </span>
  
<span class="class"><span class="keyword">@class</span> <span class="title">Person</span>;  </span>
  
<span class="class"><span class="keyword">@interface</span> <span class="title">Card</span> : <span class="title">NSManagedObject</span>  </span>
  
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSString</span> * no;  
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) Person *person;  
  
<span class="keyword">@end</span>
</pre></td></tr></table></figure>


<p>Card.m</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">#import <span class="title">"Card.h"</span>  </span>
<span class="preprocessor">#import <span class="title">"Person.h"</span>  </span>
  
<span class="class"><span class="keyword">@implementation</span> <span class="title">Card</span>  </span>
  
<span class="keyword">@dynamic</span> no;  
<span class="keyword">@dynamic</span> person;  
  
<span class="keyword">@end</span>
</pre></td></tr></table></figure>


<p>那么往数据库中添加数据的时候就应该写了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>Person *person = [NSEntityDescription insertNewObjectForEntityForName:@<span class="string">"Person"</span> inManagedObjectContext:context];  
person.name = @<span class="string">"MJ"</span>;  
person.age = [NSNumber numberWithInt:<span class="number">27</span>];  
  
Card *card = [NSEntityDescription insertNewObjectForEntityForName:@”Card<span class="string">" inManagedObjectContext:context];  </span>
card.no = @”<span class="number">4414245465656</span><span class="string">";  </span>
person.card = card;  
<span class="comment">// 最后调用[context save&error];保存数据</span>
</pre></td></tr></table></figure>


]]></content>
    <summary type="html">
    <![CDATA[<h3 id="简介">简介</h3>
<p>大概10年前，在2005年4月，Apple发布了OS X 10.4版本，第一次引入了Core Data框架。那时YouTube也刚发布。</p>
<p>Core Data提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据]]>
    </summary>
    
      <category term="iOS" scheme="http://biancheng.me/tags/iOS/"/>
    
      <category term="Core Data" scheme="http://biancheng.me/tags/Core%20Data/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Charles(青花瓷)，在Mac环境下对android手机抓包]]></title>
    <link href="http://biancheng.me/2015/11/21/%E4%BD%BF%E7%94%A8charles(%E9%9D%92%E8%8A%B1%E7%93%B7)%EF%BC%8C%E5%9C%A8mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AF%B9android%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85/"/>
    <id>http://biancheng.me/2015/11/21/使用charles(青花瓷)，在mac环境下对android手机抓包/</id>
    <published>2015-11-21T05:50:57.000Z</published>
    <updated>2015-11-21T06:01:47.000Z</updated>
    <content type="html"><![CDATA[<h4 id="1-下载工具">1.下载工具</h4>
<p>安装抓包工具 Charles , 到<a href="http://www.charlesproxy.com/" target="_blank">官网</a>可下载到最新版本</p>
<a id="more"></a>

<h4 id="2-用安装了charles的电脑，代理待抓包anroid手机的网络连接">2.用安装了charles的电脑，代理待抓包anroid手机的网络连接</h4>
<p>首先查看Mac的网络IP地址；打开电脑Charles软件后，接着打开手机设置，进入当前wifi连接，进入wifi设置界面，找到<code>代理</code>选项，设置<code>代理</code>为手动，将服务器填为电脑的IP，端口默认为8888（在charles的proxy setting中可以改这个端口号）。这时Charles弹出确认框，点击Allow按钮即可。然后就可以通过电脑抓包<br>手机的http请求了。</p>
<h4 id="3-中文乱码问题解决">3.中文乱码问题解决</h4>
<p>在charles的content/info.plist 中 的vmoption 添加-Dfile.encoding=UTF-8<br><img src="http://7xnr36.com1.z0.glb.clouddn.com/charles.png" alt="charles"></p>
<h4 id="HTTPS抓包:">HTTPS抓包:</h4>
<p>如果不进行下面的设置，https的reqeust和response都是乱码，设置完之后https就可以抓包了。</p>
<h5 id="手机端设置">手机端设置</h5>
<p>下载Charles证书<a href="http://www.charlesproxy.com/ssl.zip" target="_blank">http://www.charlesproxy.com/ssl.zip</a>，解压后导入到手机中，然后设置-&gt;安全-&gt;凭据存储-&gt;从存储设备安装，选中证书。</p>
<p>v3.10之前的版本使用一个SSL根证书。仍然可以<a href="http://www.charlesproxy.com/assets/legacy-ssl/ssl.zip" target="_blank">下载证书</a>(安装在移动设备上)。注意,这些证书将不会在v3.10以及之后的版本有效。</p>
<p>如果你运行的是v3.10或之后,请到帮助菜单,根据子菜单SSL Proxying提示操作。</p>
<h5 id="电脑端设置">电脑端设置</h5>
<p>1、在Charles的工具栏上点击设置按钮，选择Proxy Settings…</p>
<p>切换到SSL选项卡，选中Enable SSL Proxying。（别急，选完先别关掉）</p>
<p>2、SSL选项卡的Locations里填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名。比如填api.instagram.com，Port填443</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="1-下载工具">1.下载工具</h4>
<p>安装抓包工具 Charles , 到<a href="http://www.charlesproxy.com/" target="_blank">官网</a>可下载到最新版本</p>
]]>
    
    </summary>
    
      <category term="Mac" scheme="http://biancheng.me/tags/Mac/"/>
    
      <category term="工具" scheme="http://biancheng.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git介绍一]]></title>
    <link href="http://biancheng.me/2015/11/19/git%E4%BB%8B%E7%BB%8D%E4%B8%80/"/>
    <id>http://biancheng.me/2015/11/19/git介绍一/</id>
    <published>2015-11-19T06:15:13.000Z</published>
    <updated>2015-11-19T06:18:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Git起步">Git起步</h1>
<h3 id="起步">起步</h3>
<p>本章介绍开始使用 Git 前的相关知识。我们会先了解一些版本控制工具的历史背景，然后试着让 Git 在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。读完本章，你就会明白为什么 Git 会如此流行，为什么你应该立即开始使用它。</p>
 <a id="more"></a>

<h3 id="1-1_关于版本控制">1.1 关于版本控制</h3>
<p>什么是版本控制？我真的需要吗？版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。</p>
<p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控���系统 （VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最 后是谁修改了哪个地方，从而导致出现怪异问题，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改 的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统">本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图 1-1）。</p>
<p>Git详解之一 Git起步 </p>
<p>图 1-1. 本地版本控制系统<br>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p>
<h3 id="集中化的版本控制系统">集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法（见图 1-2）。</p>
<p>图 1-2. 集中化的版本控制系统<br>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统">分布式版本控制系统</h3>
<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（见图 1-3）。</p>
<p>图 1-3. 分布式版本控制系统</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
<h3 id="1-2_Git_简史">1.2 Git 简史</h3>
<p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<ul>
<li>速度 <em> 简单的设计 </em> 对非线性开发模式的强力支持（允许上千个并行开发的分支） <em> 完全分布式 </em> 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
</ul>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统（见第三章），可以应付各种复杂的项目开发需求。</p>
<h3 id="1-3_Git_基础">1.3 Git 基础</h3>
<p>那么，简单地说，Git 究竟是怎样的一个系统呢？请注意，接下来的内容非常重要，若是理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。在开始学习 Git 的时候，请不要尝试把各种概念和其他版本控制系统（诸如 Subversion 和 Perforce 等）相比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于你准确地使用 Git 提供的各种工具。</p>
<h3 id="直接记录快照，而非差异比较">直接记录快照，而非差异比较</h3>
<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 1-4。</p>
<h3 id="Git详解之一_Git起步">Git详解之一 Git起步</h3>
<p>图 1-4. 其他系统在每个版本中记录着各个文件的具体差异</p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。</p>
<h3 id="Git详解之一_Git起步-1">Git详解之一 Git起步</h3>
<p>图 1-5. Git 保存每次更新时的文件快照</p>
<p>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。</p>
<h3 id="近乎所有操作都是本地执行">近乎所有操作都是本地执行</h3>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p>
<p>举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。</p>
<p>用 CVCS 的话，没有网络或者断开 VPN 你就无法做任何事情。但用 Git 的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。同样，在回家的路上，不用连接 VPN 你也可以继续工作。换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。比如 Perforce，如果不连到服务器，几乎什么都做不了（译注：默认无法发出命令p4 edit file 开始编辑文件，因为 Perforce 需要联网通知系统声明该文件正在被谁修订。但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。）；如果是 Subversion 或 CVS，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。</p>
<h3 id="时刻保持数据完整性">时刻保持数据完整性</h3>
<p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>
<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="number">24</span>b9da6552252987aa493b52f8696<span class="built_in">cd</span>6d3b00373
</pre></td></tr></table></figure>


<p>Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<h3 id="多数操作仅添加数据">多数操作仅添加数据</h3>
<p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p>
<p>这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。至于 Git 内部究竟是如何保存和恢复数据的，我们会在第九章讨论 Git 内部原理时再作详述。</p>
<h3 id="文件的三种状态">文件的三种状态</h3>
<p>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>
<p>图 1-6. 工作目录，暂存区域，以及本地仓库</p>
<p>每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果git clone —bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改某些文件。 </li>
<li>对修改后的文件进行快照，然后保存到暂存区域。 </li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<h3 id="1-4_安装_Git">1.4 安装 Git</h3>
<p>是时候动手尝试下 Git 了，不过得先安装好它。有许多种安装方式，主要分为两种，一种是通过编译源代码来安装；另一种是使用为特定平台预编译好的安装包。</p>
<p>从源代码安装<br>若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。Git 的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。有些 Linux 版本自带的安装包更新起来并不及时，所以除非你在用最新的 distro 或者 backports，那么从源代码安装其实该算是最佳选择。</p>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ yum install curl<span class="attribute">-devel</span> expat<span class="attribute">-devel</span> gettext<span class="attribute">-devel</span> <span class="subst">\</span> openssl<span class="attribute">-devel</span> zlib<span class="attribute">-devel</span> $ apt<span class="attribute">-get</span> install libcurl4<span class="attribute">-gnutls</span><span class="attribute">-dev</span> libexpat1<span class="attribute">-dev</span> gettext <span class="subst">\</span> libz<span class="attribute">-dev</span> libssl<span class="attribute">-dev</span>
</pre></td></tr></table></figure>


<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">http:</span>//git-scm<span class="preprocessor">.com</span>/download
</pre></td></tr></table></figure>


<p>然后编译并安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>tar -zxf git-<span class="number">1.7</span>.<span class="number">2.2</span>.tar.gz <span class="variable">$ </span>cd git-<span class="number">1.7</span>.<span class="number">2.2</span> <span class="variable">$ </span>make prefix=<span class="regexp">/usr/local</span> all <span class="variable">$ </span>sudo make prefix=<span class="regexp">/usr/local</span> install
</pre></td></tr></table></figure>


<p>现在已经可以用 git 命令了，用 git 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">git:</span>/<span class="regexp">/git.kernel.org/pub</span><span class="regexp">/scm/git</span><span class="regexp">/git.git</span>
</pre></td></tr></table></figure>


<p>在 Linux 上安装<br>如果要在 Linux 上安装预编译好的 Git 二进制安装包，可以直接用系统提供的包管理工具。在 Fedora 上用 yum 安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>yum install git-core
</pre></td></tr></table></figure>


<p>在 Ubuntu 这类 Debian 体系的系统上，可以用 apt-get 安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ apt<span class="attribute">-get</span> install git<span class="attribute">-core</span>
</pre></td></tr></table></figure>


<p>在 Mac 上安装<br>在 Mac 上安装 Git 有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图 1-7，下载地址在：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">http:</span>//code<span class="preprocessor">.google</span><span class="preprocessor">.com</span>/p/git-osx-installer
</pre></td></tr></table></figure>


<p>图 1-7. Git OS X 安装工具<br>另一种是通过 MacPorts (<a href="http://www.macports.org" target="_blank">http://www.macports.org</a>) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ <span class="built_in">sudo</span> port install git-core +svn +doc +bash_completion +gitweb
</pre></td></tr></table></figure>


<p>这种方式就不需要再自己安装依赖库了，Macports 会帮你搞定这些麻烦事。一般上面列出的安装选项已经够用，要是你想用 Git 连接 Subversion 的代码仓库，还可以加上 +svn 选项，具体将在第八章作介绍。（译注：还有一种是使用 homebrew（<a href="https://github.com/mxcl/homebrew）：brew" target="_blank">https://github.com/mxcl/homebrew）：brew</a> install git。）</p>
<p>在 Windows 上安装<br>在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 Google Code 的页面上下载 exe 安装文件并运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">http:</span>//code<span class="preprocessor">.google</span><span class="preprocessor">.com</span>/p/msysgit
</pre></td></tr></table></figure>


<p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<h3 id="1-5_初次运行_Git_前的配置">1.5 初次运行 Git 前的配置</h3>
<p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p>
<p>Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用—system 选项，读写的就是这个文件。<br>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用—global 选项，读写的就是这个文件。<br>当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以.git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。<br>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是C:\Documents and Settings\$USER。此外，Git 还会尝试找寻/etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h3 id="用户信息">用户信息</h3>
<p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>
<p>$ git config —global user.name “John Doe” $ git config —global user.email johndoe@example.com<br>如果用了 —global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉—global 选项重新配置即可，新的设定保存在当前项目的.git/config 文件里。</p>
<h3 id="文本编辑器">文本编辑器</h3>
<p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ git config --<span class="keyword">global</span> core.<span class="keyword">editor</span> emacs
</pre></td></tr></table></figure>


<h3 id="差异分析工具">差异分析工具</h3>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">merge</span><span class="string">.</span><span class="comment">tool</span> <span class="comment">vimdiff</span>
</pre></td></tr></table></figure>


<p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<h3 id="查看配置信息">查看配置信息</h3>
<p>要检查已有的配置信息，可以使用 git config —list 命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ git config --list user.name=Scott Chacon user.email=schacon@gmail.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git config user.name <span class="constant">Scott</span> <span class="constant">Chacon</span>
</pre></td></tr></table></figure>


<h3 id="1-6_获取帮助">1.6 获取帮助</h3>
<p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git help <span class="variable">$ </span>git --help <span class="variable">$ </span>man git-
</pre></td></tr></table></figure>


<p>比如，要学习 config 命令可以怎么用，运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ git <span class="built_in">help</span> config
</pre></td></tr></table></figure>


<p>我们随时都可以浏览这些帮助信息而无需连网。不过，要是你觉得还不够，可以到 Frenode IRC 服务器（irc.freenode.net）上的 #git 或 #github 频道寻求他人帮助。这两个频道上总有着上百号人，大多都有着丰富的 git 知识，并且乐于助人。</p>
<h3 id="1-7_小结">1.7 小结</h3>
<p>至此，你该对 Git 有了点基本认识，包括它和以前你使用的 CVCS 之间的差别。现在，在你的系统上应该已经装好了 Git，设置了自己的名字和电邮。接下来让我们继续学习 Git 的基础知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Git起步">Git起步</h1>
<h3 id="起步">起步</h3>
<p>本章介绍开始使用 Git 前的相关知识。我们会先了解一些版本控制工具的历史背景，然后试着让 Git 在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。读完本章，你就会明白为什么 Git 会如此流行，为什么你应该立即开始使用它。</p>
 ]]>
    
    </summary>
    
      <category term="Git" scheme="http://biancheng.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo生成静态博客]]></title>
    <link href="http://biancheng.me/2015/11/17/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://biancheng.me/2015/11/17/使用hexo在github搭建静态博客/</id>
    <published>2015-11-17T03:51:01.000Z</published>
    <updated>2015-11-17T05:13:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="先屡一下思路">先屡一下思路</h3>
<ol>
<li>首先hexo是基于nodejs的，所以必须安装nodejs </li>
<li>安装nodejs方法很多，我选择homebrew安装方式，所以需要安装它 </li>
<li>安装homebrew就很简单了，mac自带ruby脚本功能，一句话搞定 </li>
<li>hexo提交部署github需要使用git工具，所以需要安装git，用homebrew的话也是一句话搞定 </li>
<li>OK整理一下安装顺序（homebrew-nodejs-hexo-git） </li>
</ol>
<a id="more"></a>

<p>思路屡清楚了，下面安装方法整理一下 </p>
<h3 id="1-安装brewhome，一句话搞定">1.安装brewhome，一句话搞定</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)</span>”</span>
</pre></td></tr></table></figure>


<h3 id="2-0_安装nodejs">2.0 安装nodejs</h3>
<h4 id="2-1_第一种方式，brewhome安装，一句话搞定">2.1 第一种方式，brewhome安装，一句话搞定</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>brew <span class="keyword">install</span> node
</pre></td></tr></table></figure>


<h4 id="2-2_第二种方式，前提是已经安装好Xcode和git，安装git方法在下面介绍">2.2 第二种方式，前提是已经安装好Xcode和git，安装git方法在下面介绍</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>git clone git:<span class="comment">//github.com/joyent/node.git</span>
cd node
./configure
<span class="built_in">make</span>
sudo <span class="built_in">make</span> install
</pre></td></tr></table></figure>


<h4 id="2-3_第三种方式，下载源码(_http://nodejs-org/download/_)，编译执行同上">2.3 第三种方式，下载源码( <a href="http://nodejs.org/download/" target="_blank">http://nodejs.org/download/</a> )，编译执行同上</h4>
<h3 id="3-0_安装hexo">3.0 安装hexo</h3>
<h4 id="3-1_第一种方式，用nodejs自带npm安装">3.1 第一种方式，用nodejs自带npm安装</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>npm <span class="keyword">install</span> -g hexo
hexo init
npm <span class="keyword">install</span>
</pre></td></tr></table></figure>


<h4 id="3-2_第二种方式，下载源码(_http://www-nodejs-org/download/_)，编译执行">3.2 第二种方式，下载源码( <a href="http://www.nodejs.org/download/" target="_blank">http://www.nodejs.org/download/</a> )，编译执行</h4>
<h3 id="4-0_安装git">4.0 安装git</h3>
<h4 id="4-1_第一种方式，homebrew安装，一句话搞定">4.1 第一种方式，homebrew安装，一句话搞定</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">sudo</span> brew install git
</pre></td></tr></table></figure>


<h4 id="4-2_第二种方式，前提是已经安装好Xcode">4.2 第二种方式，前提是已经安装好Xcode</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>curl -O http://kernel<span class="preprocessor">.org</span>/pub/software/scm/git/git-<span class="number">1.7</span><span class="number">.5</span><span class="preprocessor">.tar</span><span class="preprocessor">.bz</span>2
tar xjvf git-<span class="number">1.7</span><span class="number">.4</span><span class="number">.1</span><span class="preprocessor">.tar</span><span class="preprocessor">.bz</span>2
cd git-<span class="number">1.7</span><span class="number">.4</span><span class="number">.1</span>
./configure --prefix=/usr/local
make
sudo make install
which git
</pre></td></tr></table></figure>


<h4 id="4-3_第三种方式，下载源码(_https://www-kernel-org/pub/software/scm/git/_)，编译执行同上">4.3 第三种方式，下载源码( <a href="https://www.kernel.org/pub/software/scm/git/" target="_blank">https://www.kernel.org/pub/software/scm/git/</a> )，编译执行同上</h4>
<h4 id="4-4_第四种方式：图形界面安装OpenInGitGui(_https://code-google-com/p/git-osx-installer_)，但是天朝被墙">4.4 第四种方式：图形界面安装OpenInGitGui( <a href="https://code.google.com/p/git-osx-installer" target="_blank">https://code.google.com/p/git-osx-installer</a> )，但是天朝被墙</h4>
<h4 id="4-5_配置">4.5 配置</h4>
<h5 id="4-5-1_检查SSH_key">4.5.1 检查SSH key</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">cd</span> ~/.ssh
</pre></td></tr></table></figure>


<h5 id="4-5-2_备份已有的key，（如果有的话）">4.5.2 备份已有的key，（如果有的话）</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">mkdir</span> key_backup
mv id_rsa* key_backup
</pre></td></tr></table></figure>


<h5 id="4-5-3_生成SSH_key">4.5.3 生成SSH key</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ssh<span class="attribute">-keygen</span> <span class="attribute">-t</span> rsa <span class="attribute">-C</span> <span class="string">"xxxx@xxxx.com”</span>
</pre></td></tr></table></figure>


<h5 id="4-5-4_将SSH_key添加到Github">4.5.4 将SSH key添加到Github</h5>
<p>登录到GitHub页面，Account Settings-&gt;SSH Public Keys-&gt;Add another key将生成的key(id_rsa.pub文件）内容copy到输入框中，save。 </p>
<h5 id="4-5-5_测试连接">4.5.5 测试连接</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ssh git<span class="variable">@github</span>.com
</pre></td></tr></table></figure>


<h5 id="4-5-6_设置个人信息">4.5.6 设置个人信息</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">user</span><span class="string">.</span><span class="comment">name</span> <span class="comment">"treason258”</span>
<span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">user</span><span class="string">.</span><span class="comment">email</span> <span class="comment">ma</span><span class="string">.</span><span class="comment">tengfei2008@163</span><span class="string">.</span><span class="comment">com</span>
</pre></td></tr></table></figure>


<h3 id="5_修改hexo根目录下_config-yml文件（xxxx为你的github账户名称）">5 修改hexo根目录下_config.yml文件（xxxx为你的github账户名称）</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="label">deploy:</span>
  type: github
  repo: git@github<span class="preprocessor">.com</span>:xxxx/xxxx<span class="preprocessor">.github</span><span class="preprocessor">.io</span><span class="preprocessor">.git</span>
  branch: master
</pre></td></tr></table></figure>


<h3 id="6_注册github账号，新建名为xxxx-github-io的repository">6 注册github账号，新建名为xxxx.github.io的repository</h3>
<p>到这，Hexo博客搭建已经完成了，并且可以git提交到github上，通过访问xxxx.github.io就可以访问本博客，关于hexo的一些操作以后有时间再整理吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="先屡一下思路">先屡一下思路</h3>
<ol>
<li>首先hexo是基于nodejs的，所以必须安装nodejs </li>
<li>安装nodejs方法很多，我选择homebrew安装方式，所以需要安装它 </li>
<li>安装homebrew就很简单了，mac自带ruby脚本功能，一句话搞定 </li>
<li>hexo提交部署github需要使用git工具，所以需要安装git，用homebrew的话也是一句话搞定 </li>
<li>OK整理一下安装顺序（homebrew-nodejs-hexo-git） </li>
</ol>
]]>
    
    </summary>
    
      <category term="hexo" scheme="http://biancheng.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift中switch使用]]></title>
    <link href="http://biancheng.me/2015/11/11/swift%E4%B8%ADswitch%E4%BD%BF%E7%94%A8/"/>
    <id>http://biancheng.me/2015/11/11/swift中switch使用/</id>
    <published>2015-11-11T07:14:52.000Z</published>
    <updated>2015-11-12T09:42:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Switch简介">Switch简介</h3>
<p>Switch作为选择结构中必不可少的语句也被加入到了Swift中，只要有过编程经验的人对Switch语句都不会感到陌生，但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性。使用Switch语句很简单：</p>
<a id="more"></a>



<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> i = <span class="number">0</span>  
<span class="keyword">switch</span> i {  
    <span class="keyword">case</span> <span class="number">0</span>:  
        <span class="string">"0"</span> <span class="comment">//被输出  </span>
    <span class="keyword">case</span> <span class="number">1</span>:  
        <span class="string">"1"</span>  
    <span class="keyword">default</span>:  
        <span class="string">"2"</span>  
}
</pre></td></tr></table></figure>


<p>在这个最简单的Switch语句中，与其他语言很不同的一点是：不用显式的加上break。Swift的Switch语句会自动在case结尾处加上break，执行完满足条件的case部分后，就自动退出了。但是在某些情况下，我们可能会希望Switch能同时执行两条case，那么可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> i = <span class="number">3</span>  
<span class="keyword">switch</span> i {  
    <span class="keyword">case</span> <span class="number">0</span>,<span class="number">3</span>:  
        <span class="string">"0"</span> <span class="comment">//被输出  </span>
    <span class="keyword">case</span> <span class="number">1</span>:  
        <span class="string">"1"</span>  
    <span class="keyword">default</span>:  
        <span class="string">"2"</span>  
}
</pre></td></tr></table></figure>


<p>在case后的多个条件中，用逗号隔开即可。<br>如果就是想执行完一条case之后，想继续执行下一条case，就要用到一个新的关键字：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> i =<span class="number"> 0</span>  
<span class="keyword">switch</span> i {  
    <span class="keyword">case</span><span class="number"> 0</span>:  
        <span class="string">"0"</span> <span class="comment">//被输出  </span>
        <span class="keyword">fallthrough</span>  
    <span class="keyword">case</span><span class="number"> 1</span>:  
        <span class="string">"1"</span> <span class="comment">//被输出  </span>
    <span class="keyword">case</span><span class="number"> 2</span>:  
        <span class="string">"2"</span>  
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>使用新的关键字fallthrough能使Switch在执行完一个case之后，紧接着执行下一条case。<br>Swift的Switch语句一定要涵盖所有的情况，这并不是说一定要有default，只要上面的case能满足所有的情况，就可以不用写default。<br>需要注意的地方有两点：<br>Switch当然也支持显式的break，通常只有一种情况下你会这么做，那就是当你也不想在default里做任何事情的时候，这个时候你就可以在default里显式地加上一句break。<br>fallthrough并不是在任何情况下都有效，当你在Switch里使用Value Binding技术的时候，fallthrough就被禁止了。Value Binding在下面会讲到。</p>
<p>支持多种数据类型<br>在Objective-C里，Switch语句只能支持整形的数据（或者一个字符），但是在Swift里，Switch能支持多种数据类型，包括浮点、布尔、字符串等：<br>支持浮点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">let</span> <span class="keyword">float</span> = <span class="number">1.5</span>  
<span class="keyword">switch</span> <span class="keyword">float</span> {  
    <span class="keyword">case</span> <span class="number">1.5</span>:  
        <span class="string">"1.5"</span>   <span class="comment">//被输出  </span>
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>支持布尔：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">let</span> isSuccess = <span class="keyword">true</span>  
<span class="keyword">switch</span> isSuccess {  
    <span class="keyword">case</span> <span class="keyword">true</span>:  
        <span class="string">"true"</span>   <span class="comment">//被输出  </span>
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>支持字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">let</span> name = <span class="string">"Bannings"</span>  
<span class="keyword">switch</span> name {  
    <span class="keyword">case</span> <span class="string">"Bannings"</span>:  
        <span class="string">"Bannings"</span>   <span class="comment">//被输出  </span>
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>可以说是史上支持数据类型最多的Switch了。</p>
<h3 id="支持区间运算符">支持区间运算符</h3>
<p>不仅仅是循环结构里可以用区间运算符，在Switch里同样可以用区间运算符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>var i = <span class="number">15</span>  
<span class="keyword">switch</span> i {  
    case <span class="number">0</span> <span class="keyword">...</span> <span class="number">10</span>:  
        <span class="string">"0~10"</span>  
    case <span class="number">11</span> <span class="keyword">...</span> <span class="number">20</span>:  
        <span class="string">"11~20"</span> //被输出  
    default:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>对某个数值区间进行批量匹配，这样是不是很酷？浮点数也同样支持区间运算符。</p>
<h3 id="支持元组">支持元组</h3>
<p>作为被大大增强的Switch，元组也是被支持的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">let</span> request = (<span class="keyword">true</span>,<span class="string">"success"</span>)  
<span class="keyword">switch</span> request {  
    <span class="keyword">case</span> (<span class="keyword">true</span>, <span class="string">"success"</span>):  
        <span class="string">"success"</span>   <span class="comment">//被输出  </span>
    <span class="keyword">case</span> (<span class="keyword">false</span>, <span class="string">"failed"</span>):  
        <span class="string">"failed"</span>  
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>使用元组和使用其他数据类型一致，不过元组还有一项特点，对于不想关心的值，可以用下划线_跳过，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">let</span> (name,  _, age) = (<span class="string">"Bannings"</span> ,<span class="keyword">true</span>, <span class="number">22</span>)  
那么在使用Switch时，同样支持这项特性：
<span class="keyword">let</span> request = (<span class="keyword">true</span>,<span class="string">"success"</span>)  
<span class="keyword">switch</span> request {  
    <span class="keyword">case</span> (_, <span class="string">"success"</span>):  
        <span class="string">"success"</span>   <span class="comment">//被输出  </span>
    <span class="keyword">case</span> (<span class="keyword">false</span>, _):  
        <span class="string">"failed"</span>  
    <span class="keyword">default</span>:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<p>对于不关心的值跳过，只要满足另一个值就行了。需要注意一点的是，如果元组中的值也是数字类型，那么也是可以用区间运算符的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>let request = (<span class="number">10</span>,<span class="string">"failed"</span>)  
<span class="keyword">switch</span> request {  
    case (_, <span class="string">"success"</span>):  
        <span class="string">"success"</span>  
    case (<span class="number">1</span> <span class="keyword">...</span> <span class="number">10</span>, _):  
        <span class="string">"1~10"</span>    //被输出  
    default:  
        <span class="string">"default"</span>  
}
</pre></td></tr></table></figure>


<h3 id="Value_Binding">Value Binding</h3>
<p>针对元组，Switch还支持类似于Optional Binding的Value Binding，就是能把元组中的各个值提取出来，然后直接在下面使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">let</span> request = (<span class="number">0</span>,<span class="string">"success"</span>)  
<span class="keyword">switch</span> request {  
    <span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> state):  
        state    <span class="comment">//被输出:success  </span>
    <span class="keyword">case</span> (<span class="keyword">let</span> errorCode, _):  
        <span class="string">"error code is \(errorCode)"</span>  
}  <span class="comment">// 涵盖了所有可能的case，不用写default了  </span>
这样也是可以的：
<span class="keyword">let</span> request = (<span class="number">0</span>,<span class="string">"success"</span>)  
<span class="keyword">switch</span> request {  
    <span class="keyword">case</span> <span class="keyword">let</span> (errorCode, state):  
        state    <span class="comment">//被输出:success  </span>
    <span class="keyword">case</span> (<span class="keyword">let</span> errorCode, _):  
        <span class="string">"error code is \(errorCode)"</span>  
}
</pre></td></tr></table></figure>


<p>把let放在外面和放在里面为每一个元素单独写上let是等价的。<br>当你在一个case里使用Value Binding的时候，如果你同时也在它的上一个case里使用了fallthrough，这是编译器所不允许的，你可能会收到这样一个编译错误：</p>
<p>只要把下面的errorCode去掉就行了，当然，考虑好自己的逻辑。</p>
<h3 id="支持额外的逻辑判断">支持额外的逻辑判断</h3>
<p>在使用Switch语句时，Switch会适当地导向相应的case部分，这其实就相当于做了一次逻辑判断，但Swift的Switch语句还支持额外的逻辑判断：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">let</span> request = (<span class="number">0</span>,<span class="string">"success"</span>)  
<span class="keyword">switch</span> request {  
    <span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> state) <span class="keyword">where</span> state != <span class="string">"success"</span>:  
        state  
    <span class="keyword">case</span> (<span class="keyword">let</span> errorCode, _):  
        <span class="string">"error code is \(errorCode)"</span><span class="comment">//被输出:"error code is 0"  </span>
}
</pre></td></tr></table></figure>


<p>这同样很酷，相信在某种情况下会派上大用场。</p>
<h3 id="总结">总结</h3>
<p>Swift对Switch进行了大大增强，使Switch的灵活性得到了很大提升，这是激动人心的改变，但是如果掌控不好其中的变化，可能会使你在进行错误排查时增加难度，也会使代码复杂度变高。在适当地时候灵活运用，保持头脑清晰总是有益的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Switch简介">Switch简介</h3>
<p>Switch作为选择结构中必不可少的语句也被加入到了Swift中，只要有过编程经验的人对Switch语句都不会感到陌生，但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性。使用Switch语句很简单：</p>
]]>
    
    </summary>
    
      <category term="swift" scheme="http://biancheng.me/tags/swift/"/>
    
      <category term="iOS" scheme="http://biancheng.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 & AFNetworking 2.X]]></title>
    <link href="http://biancheng.me/2015/10/22/afnetworking-30-&-afnetworking-2x/"/>
    <id>http://biancheng.me/2015/10/22/afnetworking-30-&-afnetworking-2x/</id>
    <published>2015-10-22T05:44:09.000Z</published>
    <updated>2015-10-22T06:10:49.000Z</updated>
    <content type="html"><![CDATA[<p>AFNetworking是一款在OS X和iOS下都令人喜爱的网络库。为了迎合iOS新版本的升级, AFNetworking在3.0版本中删除了基于 NSURLConnection API的所有支持。如果你的项目以前使用过这些API，建议您立即升级到基于 NSURLSession 的API的AFNetworking的版本。本指南将引导您完成这个过程。</p>
<p>本指南是为了引导使用AFNetworking 2.x升级到最新的版本API，以达到过渡的目的，并且解释了新增和更改的设计结构。</p>
<a id="more"></a>

<h3 id="新设备要求:_iOS_7,_Mac_OS_X_10-9,_watchOS_2,_tvOS_9,_&amp;_Xcode_7">新设备要求: iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7</h3>
<p>AFNetworking 3.0正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。如果你想使用AFNetworking在针对较旧版本的SDK项目，请检查README的兼容性信息。</p>
<h3 id="NSURLConnection的API已废弃">NSURLConnection的API已废弃</h3>
<p>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。</p>
<p>AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p>
<h3 id="弃用的类">弃用的类</h3>
<p>下面的类已从AFNetworking 3.0中废弃：</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<h3 id="修改的类">修改的类</h3>
<p>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构:</p>
<ul>
<li>UIImageView+AFNetworking</li>
<li>UIWebView+AFNetworking</li>
<li>UIButton+AFNetworking</li>
</ul>
<p>迁移</p>
<p>AFHTTPRequestOperationManager 核心代码</p>
<p>如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化：</p>
<ul>
<li>securityPolicy</li>
<li>requestSerializer</li>
<li>responseSerializer</li>
</ul>
<p>接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</p>
<p>AFNetworking 2.x</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@<span class="string">"请求的url"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {
<span class="built_in">NSLog</span>(@<span class="string">"成功"</span>);
} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) {
<span class="built_in">NSLog</span>(@<span class="string">"失败"</span>);
}];
</pre></td></tr></table></figure>


<p>AFNetworking 3.0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>AFHTTPSessionManager *session = [AFHTTPSessionManager manager];
[session GET:@<span class="string">"请求的url"</span> parameters:<span class="literal">nil</span> success:^(NSURLSessionDataTask *task, <span class="keyword">id</span> responseObject) {
<span class="built_in">NSLog</span>(@<span class="string">"成功"</span>);
} failure:^(NSURLSessionDataTask *task, <span class="built_in">NSError</span> *error) {
<span class="built_in">NSLog</span>(@<span class="string">"失败"</span>);        
}];
</pre></td></tr></table></figure>


<h3 id="AFHTTPRequestOperation_核心代码">AFHTTPRequestOperation 核心代码</h3>
<p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。</p>
<p>在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。</p>
<p>接下来，将要通过AFHTTPSessionManager创建一个单例，并创建一个任务和启动它。</p>
<p>AFNetworking 2.x</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:@<span class="string">""</span>];
<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op<span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {
<span class="built_in">NSLog</span>(@<span class="string">"JSON: %@"</span>, responseObject);
} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {
<span class="built_in">NSLog</span>(@<span class="string">"Error: %@"</span>, error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</pre></td></tr></table></figure>


<p>AFNetworking 3.0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:@<span class="string">""</span>];
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager GET:URL<span class="variable">.absoluteString</span> parameters:<span class="literal">nil</span> success:^(NSURLSessionTask *task, <span class="keyword">id</span> responseObject) {
<span class="built_in">NSLog</span>(@<span class="string">"JSON: %@"</span>, responseObject);
} failure:^(NSURLSessionTask *operation, <span class="built_in">NSError</span> *error) {
<span class="built_in">NSLog</span>(@<span class="string">"Error: %@"</span>, error);
}];
</pre></td></tr></table></figure>


<h3 id="UIKit的迁移">UIKit的迁移</h3>
<p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。</p>
<p>UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p>
<h3 id="UIAlertView的类目被废弃">UIAlertView的类目被废弃</h3>
<p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>AFNetworking是一款在OS X和iOS下都令人喜爱的网络库。为了迎合iOS新版本的升级, AFNetworking在3.0版本中删除了基于 NSURLConnection API的所有支持。如果你的项目以前使用过这些API，建议您立即升级到基于 NSURLSession 的API的AFNetworking的版本。本指南将引导您完成这个过程。</p>
<p>本指南是为了引导使用AFNetworking 2.x升级到最新的版本API，以达到过渡的目的，并且解释了新增和更改的设计结构。</p>
]]>
    
    </summary>
    
      <category term="第三方库" scheme="http://biancheng.me/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
      <category term="iOS" scheme="http://biancheng.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[随和的人更幸福]]></title>
    <link href="http://biancheng.me/2014/11/21/%E9%9A%8F%E5%92%8C%E7%9A%84%E4%BA%BA%E6%9B%B4%E5%B9%B8%E7%A6%8F/"/>
    <id>http://biancheng.me/2014/11/21/随和的人更幸福/</id>
    <published>2014-11-21T15:36:50.000Z</published>
    <updated>2015-11-07T05:10:19.000Z</updated>
    <content type="html"><![CDATA[<p>随和的人更幸福。</p>
<p>随和是什么？有人说，随和就是不计较，不争斗，遇事而安，和和气气的态度，随和体现在友善的气质。笔者试从四个方面来分析什么事随和：<br><a id="more"></a></p>
<p>（一）随和是一种素质<br>    当今社会，随和体现的是一种素质，这种素质需要学习与沉淀，随和的人以团队为中心，而不是以自我为中心，即便您毕业于名牌大学，即便您有漂亮的外表，即便您比别人聪明，都要学会团队精神，学会随和。笔者见过这样的朋友，在团队中，气势要压过别人，凡事都争个上风，斤斤计较自己的名誉、地位，什么都要比人家好，结果往往造成人际关系不和谐。<br>    生活中，工作中，做一个随和的人，笔者认为，随和是一种素质，随和的人，善于发现周围其他人的真善美，善于发现周围朋友的优点，善于享受生活赐予我们的快乐，随和的人，心胸宽广，视野宽阔，智慧无比。随和是一种素质，无论在生活中，还是工作中，做一个随和的人吧。</p>
<p>（二）随和是一种修养<br>    随着是一种修养，随和的人善于聆听，随和的人善于与不同性格特点的人进行沟通，随和的人常常换位思考，随和的人真诚地赞扬别人。随和是一种修养，这种修养是一种积累之后的沉淀，这种修养体现在举手投足之间的美丽。随和不是没有原则，而是善于从周围朋友的角度来看事物与问题，随和的人不是没有人云亦云，随和的人不是随波逐流，而是从善于从不同的看法与观点中找到共同点，与人为善，善待他人，多一份坦然，添一份好心情。随和是一种修养，随和的人是智慧的人，随和一些，享受生活。</p>
<p>（三）随和是一种文化<br>    在一个组织中，随和的团队氛围，会让每一个成员感到轻松，感到愉悦，随和的人更容易融入到团队中，即便您的能力不是最强，但随和的性格会让你在团队中很快进步与成长。随和是一种文化，这种文化不仅体现在组织文化中，更体现在文化给予每个成员的力量与进步。随和的文化促进组织每一位成员成长与进步，反过来促进组织的成长与进步。反之，如果没有随和的组织文化，每一个成员都以自我为中心，会影响到组织的凝聚力，会破坏组织的团结，反过来影响组织的进步与成长。随和是一种文化，这种文化需要组织每一个成员的随和。</p>
<p>（四）随和是一种心态<br>    俗话说，态度决定一切，心态就是性格加态度。性格是一个人独特而稳定的个性特征，它表现一个人对现实的心理认知和相应的习惯化的行为方式。态度是一个人对客观事物的心理反应。有人说，心态要有三种构成模式：骆驼的心态，狮子的心态，婴儿的心态。笔者认为，首先你要学会随和。随和的人更容易从其他人身上学习到长处与优点，随和的人在聆听周围的同时，也会得到周围的聆听。苏格拉底也有一句名言：“快乐就是这样，它往往在你为着一个明确的目标忙得无暇顾及其他的时候而不知不觉地来到。”同样，当你把目标锁定，“只问耕耘，莫论收获”的时候，上帝也就把收获悄悄地给你预备好了。<br>    随和是一种素质，一种修养，一种文化，一种心态，随和的人更幸福。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>随和的人更幸福。</p>
<p>随和是什么？有人说，随和就是不计较，不争斗，遇事而安，和和气气的态度，随和体现在友善的气质。笔者试从四个方面来分析什么事随和：<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://biancheng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Uikit Dynamics入门]]></title>
    <link href="http://biancheng.me/2014/10/19/dynamics%E5%85%A5%E9%97%A8/"/>
    <id>http://biancheng.me/2014/10/19/dynamics入门/</id>
    <published>2014-10-19T15:36:35.000Z</published>
    <updated>2015-11-07T05:10:55.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是UIKit动力学（UIKit_Dynamics）">什么是UIKit动力学（UIKit Dynamics）</h3>
<p>其实就是UIKit的一套动画和交互体系。我们现在进行UI动画基本都是使用CoreAnimation或者UIView animations。而UIKit动力学最大的特点是将现实世界动力驱动的动画引入了UIKit，比如重力，铰链连接，碰撞，悬挂等效果。一言蔽之，即是，将2D物理引擎引入了人UIKit。需要注意，UIKit动力学的引入，并不是以替代CA或者UIView动画为目的的，在绝大多数情况下CA或者UIView动画仍然是最优方案，只有在需要引入逼真的交互设计的时候，才需要使用UIKit动力学它是作为现有交互设计和实现的一种补充而存在的。<br>目的当然是更加自然和炫目的UI动画效果，比如模拟现实的拖拽和弹性效果，放在以前如果单用iOS SDK的动画实现起来还是相当困难的，而在UIKit Dynamics的帮助下，复杂的动画效果可能也只需要很短的代码（基本100行以内…其实现在用UIView animation想实现一个不太复杂的动画所要的代码行数都不止这个数了吧）。总之，便利多多，配合UI交互设计，以前很多不敢想和不敢写（至少不敢自己写）的效果实现起来会非常方便，也相信在iOS7的时代各色使用UIKit动力学的应用的在动画效果肯定会上升一个档次。<br>那么，应该怎么���呢<br><a id="more"></a><br>UIKit动力学实现的结构<br>为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br>UIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点；<br>UIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；<br>UIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br>ReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。<br>光说不练假把式，来做点简单的demo吧。比如为一个view添加重力行为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)viewDidLoad
{
    	[<span class="keyword">super</span> viewDidLoad];

    <span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] initWithFrame:CGRectMake(<span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)];
    aView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];
    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:aView];

    UIDynamicAnimator* animator = [[UIDynamicAnimator alloc] initWithReferenceView:<span class="keyword">self</span><span class="variable">.view</span>];
    UIGravityBehavior* gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[aView]];
    [animator addBehavior:gravityBeahvior];
    <span class="keyword">self</span><span class="variable">.animator</span> = animator;
}
</pre></td></tr></table></figure>


<p>代码很简单，<br>以现在ViewController的view为参照系（ReferenceView），来初始化一个UIDynamicAnimator。<br>然后分配并初始化一个动力行为，这里是UIGravityBehavior，将需要进行物理模拟的UIDynamicItem传入。UIGravityBehavior的initWithItems:接受的参数为包含id的数组，另外UIGravityBehavior实例还有一个addItem:方法接受单个的id。就是说，实现了UIDynamicItem委托的对象，都可以看作是被力学特性影响的，进而参与到计算中。UIDynamicItem委托需要我们实现bounds，center和transform三个属性，在UIKit Dynamics计算新的位置时，需要向Behavior内的item询问这些参数，以进行正确计算。iOS7中，UIView和UICollectionViewLayoutAttributes已经默认实现了这个接口，所以这里我们直接把需要模拟重力的UIView添加到UIGravityBehavior里就行了。<br>把配置好的UIGravityBehavior添加到animator中。<br>strong持有一下animator，避免当前scope结束被ARC释放掉（后果当然就是UIView在哪儿傻站着不掉）<br>运行结果，view开始受重力影响了：<br>重力作用下的UIview<br>重力作用下的UIview<br>碰撞，我要碰撞<br>没有碰撞的话，物理引擎就没有任何意义了。和重力行为类似，碰撞也有一个UIDynamicBehavior子类来描述碰撞行为，即UICollisionBehavior。在上面的demo中加上几句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)viewDidLoad
{
    	[<span class="keyword">super</span> viewDidLoad];

    <span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] initWithFrame:CGRectMake(<span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)];
    aView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];
    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:aView];

    UIDynamicAnimator* animator = [[UIDynamicAnimator alloc] initWithReferenceView:<span class="keyword">self</span><span class="variable">.view</span>];
    UIGravityBehavior* gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[aView]];
    [animator addBehavior:gravityBeahvior];

    UICollisionBehavior* collisionBehavior = [[UICollisionBehavior alloc] initWithItems:@[aView]];
    collisionBehavior<span class="variable">.translatesReferenceBoundsIntoBoundary</span> = <span class="literal">YES</span>;
    [animator addBehavior:collisionBehavior];
    collisionBehavior<span class="variable">.collisionDelegate</span> = <span class="keyword">self</span>;

    <span class="keyword">self</span><span class="variable">.animator</span> = animator;
}
</pre></td></tr></table></figure>


<p>也许聪明的你已经看到了，还是一样的，创建新的行为规则（UICollisionBehavior），然后加到animator中…唯一区别的地方是碰撞需要设定碰撞边界范围translatesReferenceBoundsIntoBoundary将整个参照view（也就是self.view）的边框作为碰撞边界（另外你还可以使用setTranslatesReferenceBoundsIntoBoundaryWithInsets:这样的方法来设定某一个区域作为碰撞边界，更复杂的边界可以使用addBoundaryWithIdentifier:forPath:来添加UIBezierPath，或者addBoundaryWithIdentifier:fromPoint:toPoint:来添加一条线段为边界，详细地还请查阅文档）；另外碰撞是有回调的，可以在self中实现UICollisionBehaviorDelegate。<br>最后，只是直直地掉下来的话未免太无聊了，加个角度吧：<br>1<br>aView.transform = CGAffineTransformRotate(aView.transform, 45);<br>结果是这样的，帅死了…这在以前只用iOS SDK的话，够写上很长时间了吧..<br>碰撞和重力同时作用的动力UI<br>碰撞和重力同时作用的动力UI<br>碰撞的delegate可以帮助我们了解碰撞的具体情况，包括哪个item和哪个item开始发生碰撞，碰撞接触点是什么，是否和边界碰撞，和哪个边界碰撞了等信息。这些回调方法保持了Apple一向的命名原则，所以通俗易懂。需要多说一句的是回调方法中对于ReferenceView的Bounds做边界的情况，BoundaryIdentifier将会是nil，自行添加的其他边界的话，ID自然是添加时指定的ID了。<br>– collisionBehavior:beganContactForItem:withBoundaryIdentifier:atPoint:<br>– collisionBehavior:beganContactForItem:withItem:atPoint:<br>– collisionBehavior:endedContactForItem:withBoundaryIdentifier:<br>– collisionBehavior:endedContactForItem:withItem:<br>其他能实现的效果<br>除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括<br>UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…<br>UISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；<br>UIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br>UIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等<br>UIDynamicItemBehavior有一组系统定义的默认值，<br>allowsRotation YES<br>density 1.0<br>elasticity 0.0<br>friction 0.0<br>resistance 0.0<br>所有的UIDynamicBehavior都是可以独立作用的，同时作用时也遵守力的合成。也就是说，组合使用行为可以达到一些较复杂的效果。举个例子，希望模拟一个drag物体然后drop后下落的过程，可以用如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)viewDidLoad
{
    	[<span class="keyword">super</span> viewDidLoad];

    UIDynamicAnimator* animator = [[UIDynamicAnimator alloc] initWithReferenceView:<span class="keyword">self</span><span class="variable">.view</span>];
    UICollisionBehavior* collisionBehavior = [[UICollisionBehavior alloc] initWithItems:@[<span class="keyword">self</span><span class="variable">.square1</span>]];

    collisionBehavior<span class="variable">.translatesReferenceBoundsIntoBoundary</span> = <span class="literal">YES</span>;
    [animator addBehavior:collisionBehavior];

    UIGravityBehavior *g = [[UIGravityBehavior alloc] initWithItems:@[<span class="keyword">self</span><span class="variable">.square1</span>]];
    [animator addBehavior:g];

    <span class="keyword">self</span><span class="variable">.animator</span> = animator;
}


-(<span class="keyword">IBAction</span>)handleAttachmentGesture:(UIPanGestureRecognizer*)gesture
{
    <span class="keyword">if</span> (gesture<span class="variable">.state</span> == UIGestureRecognizerStateBegan){

        <span class="built_in">CGPoint</span> squareCenterPoint = CGPointMake(<span class="keyword">self</span><span class="variable">.square1</span><span class="variable">.center</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.square1</span><span class="variable">.center</span><span class="variable">.y</span> - <span class="number">100.0</span>);

        UIAttachmentBehavior* attachmentBehavior = [[UIAttachmentBehavior alloc] initWithItem:<span class="keyword">self</span><span class="variable">.square1</span> attachedToAnchor:squareCenterPoint];

        <span class="keyword">self</span><span class="variable">.attachmentBehavior</span> = attachmentBehavior;
        [<span class="keyword">self</span><span class="variable">.animator</span> addBehavior:attachmentBehavior];

    } <span class="keyword">else</span> <span class="keyword">if</span> ( gesture<span class="variable">.state</span> == UIGestureRecognizerStateChanged) {

        [<span class="keyword">self</span><span class="variable">.attachmentBehavior</span> setAnchorPoint:[gesture locationInView:<span class="keyword">self</span><span class="variable">.view</span>]];

    } <span class="keyword">else</span> <span class="keyword">if</span> (gesture<span class="variable">.state</span> == UIGestureRecognizerStateEnded) {
        [<span class="keyword">self</span><span class="variable">.animator</span> removeBehavior:<span class="keyword">self</span><span class="variable">.attachmentBehavior</span>];
    }
}
</pre></td></tr></table></figure>


<p>viewDidiLoad时先在现在环境中加入了重力，然后监测到pan时附加一个UIAttachmentBehavior，并在pan位置更新更新其锚点，此时UIAttachmentBehavior和UIGravityBehavior将同时作用（想象成一根木棒连着手指处和view）。在手势结束时将这个UIAttachmentBehavior移除，view将在重力作用下下落。整个过程如下图：<br>Drag &amp; Drop<br>Drag &amp; Drop<br>UIKit力学的物理学分析<br>既然是力学，那显然各种单位是很重要的。在现实世界中，理想情况下物体的运动符合牛顿第二运动定理，在国际单位制中，力的单位是牛顿（N），距离单位是米（m），时间单位是秒（s），质量单位是千克（kg）。根据地球妈妈的心情，我们生活在这样一套体制中：重力加速度约为9.8m/s2 ，加速度的单位是m/s2 ，速度单位是m/s，牛顿其实是kg·m/s2 ，即1牛顿是让质量为1千克的物体产生1米每二次方秒的加速度所需要的力。<br>以上是帮助您回忆初中知识，而现在这一套体系在UIKit里又怎么样呢？这其实是每一个物理引擎都要讨论和明白的事情，UIKit的单位体制里由于m这个东西太过夸张，因此用等量化的点（point，之后简写为p）来代替。具体是这样的：UI重力加速度定义为1000p/s2 ，这样的定义有两方面的考虑，一时为了简化，好记，确实1000比9.8来的只观好看，二是也算符合人们的直感：一个UIView从y=0开始自由落体落到屏幕底部所需的时间，在3.5寸屏幕上为0.98秒，4寸屏幕上为1.07秒，1秒左右的自由落体的视觉效果对人眼来说是很舒服能进行判断的。<br>那么UIView的质量又如何定义呢，这也是很重要的，并涉及到力作用和加速度下UIView的表现。苹果又给出了自己的“UIKit牛顿第二定律”，定义了1单位作用力相当于将一个100px100p的默认密度的UIView以100p/s2 的加速度移动。这里需要注意默认密度这个假设，因为在UIDynamicItem的委托中并没有实现任何密度相关的定义，而是通过UIDynamicItemBehavior来附加指定的。默认情况下，密度值为1，这就相当于质量是10000单位的UIView在1单位的作用力下可以达到1/10的UI重力加速度。<br>这样类比之后的结论是，如果将1单位的UI力学中的力等同于1牛顿的话：<br>1000单位的UI质量，与现实世界中1kg的质量相当，即一个点等同一克；<br>屏幕的100像素的长度，约和现实世界中0.99米相当（完全可以看为1米）<br>UI力学中的默认密度，约和现实世界的0.1kg/m2 相当<br>可以说UIKit为我们构建了一套适应iOS屏幕的相当优雅的力学系统，不仅让人过目不忘，在实际的物理情景和用户体验中也近乎完美。在开发中，我们可以参照这些关系寻找现实中的例子，然后将其带入UIKit的力学系统中，以得到良好的模拟效果。<br>UIKit动力学自定义<br>除了SDK预先定义好的行为以外，我们还可以自己定义想要的行为。这种定义可以发生在两个层级上，一种是将官方的行为打包，以简化实现。另一种是完全定义新的计算规则。<br>对于第一种，其实考虑一下上面的重力+边界碰撞，或者drag &amp; drop行为，其实都是两个甚至多个行为的叠加。要是每次都这样设定一次的话，不是很辛苦么，还容易遗忘出错。于是一种好的方式是将它们打包封装一下。具体地，如下步骤：<br>继承一下UIDynamicBehavior（在这里UIDynamicBehavior类似一个抽象类，并没有具体实现什么行为）<br>在子类中实现一个类似其他内置行为初始化方法initWithItems:，用以添加物体和想要打包的规则。当然你如果喜欢用其他方式也行..只不过和自带的行为保持API统一对大家都有好处..添加item的话就用默认规则的initWithItems:就行，对于规则UIDynamicBehavior提供了一个addChildBehavior:的方法，来将其他规则加入到当前规则里<br>没有第三步了，使用就行了。<br>一个例子，打包了碰撞和重力两种行为，定义之后使用时就只需要写一次了。当然这只是最简单的例子和运用，当行为复杂以后，这样的使用方法是不可避免的，否则管理起来会让人有想死的心。另外，将手势等交互的方式也集成之中，进一步封装调用细节会是不错的实践。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">//GravityWithCollisionBehavior.h</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">GravityWithCollisionBehavior</span> : <span class="title">UIDynamicBehavior</span></span>

-(instancetype) initWithItems:(<span class="built_in">NSArray</span> *)items;

<span class="keyword">@end</span>


<span class="comment">//GravityWithCollisionBehavior.m</span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">GravityWithCollisionBehavior</span></span>

-(instancetype) initWithItems:(<span class="built_in">NSArray</span> *)items
{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
        UIGravityBehavior *gb = [[UIGravityBehavior alloc] initWithItems:items];
        UICollisionBehavior *cb = [[UICollisionBehavior alloc] initWithItems:items];
        cb<span class="variable">.translatesReferenceBoundsIntoBoundary</span> = <span class="literal">YES</span>;
        [<span class="keyword">self</span> addChildBehavior:gb];
        [<span class="keyword">self</span> addChildBehavior:cb];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</pre></td></tr></table></figure>


<p>@end<br>另一种比较高级一点，需要对计算完全定义。在默认的行为或者它们组合不能满足禽兽般的产品经理/设计师的需求是，亲爱的骚年..开始自己写吧..其实说简单也简单，UIDynamicBehavior里提供了一个@property(nonatomic, copy) void (^action)(void)，animator将在每次animation step（就是需要计算动画时）调用这个block。就是说，你可以通过设定这个block来实现自己的行为。基本思路就是在这个block中向所有item询问它们当前的center和transform状态，然后开始计算，然后把计算后的相应值再赋予item，从而改变在屏幕上的位置，大小，角度等。<br>UIKit动力学的性能分析和限制<br>使用物理引擎不是没有代价的的，特别是在碰撞检测这块，是要耗费一定CPU资源的。但是以测试的情况来看，如果只是UI层面上的碰撞检测还是没有什么问题的，我自己实测iPhone4上同时进行数十个碰撞计算完全没有掉帧的情况。因此如果只是把其用在UI特效上，应该不用太在意资源的耗费。但是如果同时有成百上千的碰撞需要处理的情况，可能会出现卡顿吧。<br>对于UIDynamicItem来说，当它们被添加到动画系统后，我们只能通过动画系统来改变位置，而外部的对于UIDynamicItem的center,transform等设定是被忽略的（其实这也是大多数2D引擎的实现策略，算不上限制）。<br>主要的限制是在当计算迭代无法得到有效解的时候，动画将无法正确呈现。这对于绝大多数物理引擎都是一样的。迭代不能收敛时整个物理系统处于不确定的状态，比如初始时就设定了碰撞物体位于边界内部，或者在狭小空间内放入了过多的非弹性碰撞物体等。另外，这个引擎仅仅只是用来呈现UI效果，它并没有保证物理上的精确度，因此如果要用它来做UI以外的事情，有可能是无法得到很好的结果的。<br>总结<br>总之就是一套全新的UI交互的视觉体验和效果，但是并非处处适用。在合适的地方使用可以增加体验，但是也会有其他方式更适合的情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是UIKit动力学（UIKit_Dynamics）">什么是UIKit动力学（UIKit Dynamics）</h3>
<p>其实就是UIKit的一套动画和交互体系。我们现在进行UI动画基本都是使用CoreAnimation或者UIView animations。而UIKit动力学最大的特点是将现实世界动力驱动的动画引入了UIKit，比如重力，铰链连接，碰撞，悬挂等效果。一言蔽之，即是，将2D物理引擎引入了人UIKit。需要注意，UIKit动力学的引入，并不是以替代CA或者UIView动画为目的的，在绝大多数情况下CA或者UIView动画仍然是最优方案，只有在需要引入逼真的交互设计的时候，才需要使用UIKit动力学它是作为现有交互设计和实现的一种补充而存在的。<br>目的当然是更加自然和炫目的UI动画效果，比如模拟现实的拖拽和弹性效果，放在以前如果单用iOS SDK的动画实现起来还是相当困难的，而在UIKit Dynamics的帮助下，复杂的动画效果可能也只需要很短的代码（基本100行以内…其实现在用UIView animation想实现一个不太复杂的动画所要的代码行数都不止这个数了吧）。总之，便利多多，配合UI交互设计，以前很多不敢想和不敢写（至少不敢自己写）的效果实现起来会非常方便，也相信在iOS7的时代各色使用UIKit动力学的应用的在动画效果肯定会上升一个档次。<br>那么，应该怎么做呢<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://biancheng.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让别人理解]]></title>
    <link href="http://biancheng.me/2014/09/18/%E8%AE%A9%E5%88%AB%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://biancheng.me/2014/09/18/让别人理解/</id>
    <published>2014-09-18T03:20:28.000Z</published>
    <updated>2015-11-07T05:10:34.000Z</updated>
    <content type="html"><![CDATA[<p>理解分为两类，将需要理解的事物归到已经理解的，此为上策；不然，那就只能强制理解，习惯的力量是无穷的，如果习惯了，那他就应该是那样，不需要理解了。</p>
<a id="more"></a>

<p><img src="http://7xnr36.com1.z0.glb.clouddn.com/IMG_0773.JPG" alt="月季"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>理解分为两类，将需要理解的事物归到已经理解的，此为上策；不然，那就只能强制理解，习惯的力量是无穷的，如果习惯了，那他就应该是那样，不需要理解了。</p>
]]>
    
    </summary>
    
      <category term="随笔" scheme="http://biancheng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
